# generator.py
"""This module generates markdown documentation from analysis results."""
from typing import List, Dict
from pathlib import Path
from models import ProjectAnalysis, ModuleSummary


class DocumentationGenerator:
    """Generates README and technical documentation from analysis results."""
    
    def __init__(self, output_dir: str = "output"):
        """
        Initialize the documentation generator.
        
        Args:
            output_dir: Directory to save generated documentation (default: 'output')
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)

    def generate_readme(
        self, 
        project_analysis: ProjectAnalysis, 
        project_name: str
    ) -> str:
        """
        Generate README.md (overview documentation).
        
        Args:
            project_analysis: High-level project analysis from LLM
            project_name: Name of the project
            
        Returns:
            Path to generated README.md file
        """
        readme_path = self.output_dir / "README.md"
        
        content = self._build_readme_content(project_analysis, project_name)
        
        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        return str(readme_path)

    def generate_technical_doc(
        self, 
        project_analysis: ProjectAnalysis, 
        module_summaries: List[ModuleSummary],
        project_name: str
    ) -> str:
        """
        Generate TECHNICAL_DOC.md (detailed technical documentation).
        
        Args:
            project_analysis: High-level project analysis from LLM
            module_summaries: List of all module summaries from LLM
            project_name: Name of the project
            
        Returns:
            Path to generated TECHNICAL_DOC.md file
        """
        tech_doc_path = self.output_dir / "TECHNICAL_DOC.md"
        
        content = self._build_technical_doc_content(
            project_analysis, 
            module_summaries, 
            project_name
        )
        
        with open(tech_doc_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        return str(tech_doc_path)
    
    def generate_all(
        self, 
        project_analysis: ProjectAnalysis, 
        module_summaries: List[ModuleSummary],
        project_name: str
    ) -> Dict[str, str]:
        """
        Generate all documentation files (README and Technical Doc).
        
        Args:
            project_analysis: High-level project analysis from LLM
            module_summaries: List of all module summaries from LLM
            project_name: Name of the project
            
        Returns:
            Dictionary with paths to generated files:
            {
                'readme': 'path/to/README.md',
                'technical_doc': 'path/to/TECHNICAL_DOC.md'
            }
        """
        readme_path = self.generate_readme(project_analysis, project_name)
        tech_doc_path = self.generate_technical_doc(
            project_analysis, 
            module_summaries, 
            project_name
        )
        
        return {
            "readme": readme_path,
            "technical_doc": tech_doc_path
        }
    
    def _build_readme_content(
        self, 
        project_analysis: ProjectAnalysis, 
        project_name: str
    ) -> str:
        """Build README.md content string."""
        
        content = f"""# {project_name}

## Overview

{project_analysis.project_purpose}

## Architecture

{project_analysis.architecture_overview}

## Entry Points

The following files can be run directly:

"""
        
        # Add entry points
        for entry_point in project_analysis.entry_points:
            content += f"- `{entry_point}`\n"
        
        content += """

## Module Relationships

"""
        content += f"{project_analysis.module_relationships}\n"
        
        content += """

## Design Patterns

"""
        
        # Add design patterns
        if project_analysis.design_patterns:
            for pattern in project_analysis.design_patterns:
                content += f"- {pattern}\n"
        else:
            content += "No specific design patterns identified.\n"
        
        # Footer sections
        content += """

## Getting Started

[Add setup instructions here]

## Usage

[Add usage examples here]

---

*This documentation was automatically generated by the Code Documentation Agent.*
"""
        
        return content
    
    def _build_technical_doc_content(
        self, 
        project_analysis: ProjectAnalysis, 
        module_summaries: List[ModuleSummary],
        project_name: str
    ) -> str:
        """Build TECHNICAL_DOC.md content string."""
        
        content = f"""# {project_name} - Technical Documentation

## Architecture Overview

{project_analysis.architecture_overview}

## Module Relationships

{project_analysis.module_relationships}

## Design Patterns

"""
        
        # Add design patterns
        if project_analysis.design_patterns:
            for pattern in project_analysis.design_patterns:
                content += f"- **{pattern}**\n"
        else:
            content += "No specific design patterns identified.\n"
        
        content += """

---

## Module Reference

"""
        
        # Sort modules by path for consistent ordering
        sorted_summaries = sorted(module_summaries, key=lambda x: x.file_path)
        
        # Add each module's documentation
        for summary in sorted_summaries:
            content += self._format_module_section(summary)
        
        # Footer sections
        content += """

## Development Guidelines

[Add coding standards, contribution guidelines, etc.]

## Testing

[Add testing instructions]

---

*This technical documentation was automatically generated by the Code Documentation Agent.*
"""
        
        return content
    
    def _format_module_section(self, summary: ModuleSummary) -> str:
        """Format a single module's documentation section."""
        
        section = f"""
### `{summary.file_path}`

**Purpose:** {summary.purpose}

**Responsibilities:**
"""
        
        for resp in summary.responsibilities:
            section += f"- {resp}\n"
        
        section += """
**Key Components:**
"""
        
        for comp in summary.key_components:
            section += f"- `{comp}`\n"
        
        # Add dependencies if present
        if summary.dependencies:
            section += """
**Dependencies:**
"""
            for dep in summary.dependencies:
                section += f"- `{dep}`\n"
        
        section += "\n---\n"
        
        return section


if __name__ == "__main__":
    # Test the generator with sample data
    from models import ProjectAnalysis, ModuleSummary
    
    # Sample project analysis
    test_analysis = ProjectAnalysis(
        project_purpose="A test project for documentation generation",
        architecture_overview="Modular architecture with clear separation of concerns",
        entry_points=["main.py"],
        module_relationships="Modules follow a pipeline pattern",
        design_patterns=["Pipeline", "Factory"]
    )
    
    # Sample module summaries
    test_summaries = [
        ModuleSummary(
            file_path="main.py",
            purpose="Entry point and orchestration",
            responsibilities=["Coordinate pipeline", "Handle user input"],
            key_components=["main()", "orchestrate()"],
            dependencies=["os", "sys"]
        )
    ]
    
    # Generate documentation
    generator = DocumentationGenerator(output_dir="test_output")
    files = generator.generate_all(test_analysis, test_summaries, "Test Project")
    
    print("Generated files:")
    print(f"  README: {files['readme']}")
    print(f"  Technical Doc: {files['technical_doc']}")